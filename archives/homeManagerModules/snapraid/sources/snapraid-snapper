#!/usr/bin/env python

import json
import logging
import os
import shutil
import signal
import subprocess
import sys
import time
import uuid
from argparse import ArgumentParser
from concurrent.futures import Future, ThreadPoolExecutor, as_completed
from datetime import datetime
from pathlib import Path
from subprocess import DEVNULL, PIPE, Popen, TimeoutExpired
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from argparse import Namespace
    from subprocess import CompletedProcess
    from typing import Any, Literal

    SnapperSnapshotType = dict[str, Any]

PROCS_TO_CHECK = [
    "smartctl",
    "btrfs",
    "btrfstune",
    "rsync",
    "cp",
    "mv",
    "snapraid",
]
SNAPPER_DESCRIPTION = "snapraid-snapper"
SNAPPER_USERDATA_KEY_ID = "id"
MIN_SNAPRAID_TIMEOUT_SEC = 120

logging.basicConfig(
    level=logging.DEBUG,
    format="%(levelname)s: %(message)s",
    stream=sys.stderr,
)
Logger = logging.getLogger(__name__)


class Executables:
    """Stores various executable path for maximum reliabilty."""

    snapper: str | None = shutil.which("snapper")
    snapraid: str | None = shutil.which("snapraid")
    pgrep: str | None = shutil.which("pgrep")
    ionice: str | None = shutil.which("ionice")

    @classmethod
    def check(cls: type["Executables"]) -> bool:
        """Check whether all necessary executables are on the system."""

        ret: bool = True

        for exe in ("snapper", "snapraid", "pgrep", "ionice"):
            if not isinstance(getattr(cls, exe), str):
                msg = f"{exe} is not installed."
                Logger.error(msg)
                ret = False

        return ret

    @classmethod
    def get(cls: type["Executables"], exe: str) -> str:
        """Get path of executable."""
        if hasattr(cls, exe) and isinstance(getattr(cls, exe), str):
            return getattr(cls, exe)

        raise Exception


class Snapper:
    """Snapper-related functions."""

    _configs: set
    _configs_raw: dict

    sync_uuid: "uuid.UUID" = uuid.uuid4()

    @classmethod
    def status(
        cls: type["Snapper"],
        config: str,
        snapshot: "SnapperSnapshotType",
    ) -> str:
        """Run snapper status. Return raw results."""

        args = (
            Executables.get("ionice"),
            "-c",
            "3",
            Executables.get("snapper"),
            "--jsonout",
            "-c",
            config,
            "status",
            f"{snapshot['number']}..0",
        )

        msg = f"New command: {args}"
        Logger.debug(msg)

        proc = subprocess.run(args, check=True, capture_output=True, text=True)

        return proc.stdout

    @classmethod
    def get_configs_raw(cls: type["Snapper"]) -> dict:
        """Results of snapper list-configs."""

        if hasattr(cls, "_configs_raw"):
            return cls._configs_raw

        proc: "CompletedProcess" = subprocess.run(
            (Executables.get("snapper"), "--jsonout", "list-configs"),
            capture_output=True,
            text=True,
            check=True,
        )
        cls._configs_raw = json.loads(proc.stdout)["configs"]

        return cls._configs_raw

    @classmethod
    def get_configs(cls: type["Snapper"]) -> "set":
        """Get configurations of volume being used in snapraid."""
        if hasattr(cls, "_configs"):
            return cls._configs

        cls._configs = {
            dict_["config"]
            for dict_ in cls.get_configs_raw()
            if dict_["subvolume"] in SnapRAID.get_data_vols()
        }

        return cls._configs

    @classmethod
    def get_snapshots(
        cls: type["Snapper"],
        config: str,
    ) -> "list[SnapperSnapshotType]":
        """Get non-active snapraid snapshots sorted by datetime from snapper."""

        def filter_(snapshot: dict) -> bool:
            return (
                snapshot["number"] != 0
                and not snapshot["active"]
                and not snapshot["default"]
                and snapshot["description"] == SNAPPER_DESCRIPTION
                and snapshot["type"] == "single"
            )

        proc: "CompletedProcess" = subprocess.run(
            (
                Executables.get("snapper"),
                "--jsonout",
                "--utc",
                "--iso",
                "-c",
                config,
                "list",
                "--disable-used-space",
            ),
            capture_output=True,
            text=True,
            check=True,
        )

        return sorted(
            [
                {
                    "number": dict_["number"],
                    "datetime": datetime.fromisoformat(dict_["date"]),
                    SNAPPER_USERDATA_KEY_ID: dict_["userdata"].get(
                        SNAPPER_USERDATA_KEY_ID,
                    ),
                }
                for dict_ in json.loads(proc.stdout)[config]
                if filter_(dict_)
            ],
            key=lambda data: data["datetime"],
        )

    @classmethod
    def cleanup(cls: type["Snapper"]) -> None:
        """Cleanup old snapshots."""

        msg = "Cleanup old snapshots"
        Logger.info(msg)

        proc: "Popen"
        stderr: str
        args: tuple[str, ...]
        for config in cls.get_configs():
            for snapshot in cls.get_snapshots(config)[:-1]:
                msg = f"deleting {config}'s snapshot {snapshot['number']}"
                Logger.debug(msg)

                args = (
                    Executables.get("snapper"),
                    "-c",
                    config,
                    "delete",
                    str(snapshot["number"]),
                )

                with Popen(
                    args,
                    stdout=DEVNULL,
                    stderr=PIPE,
                    text=True,
                ) as proc:
                    try:
                        _, stderr = proc.communicate()
                    except KeyboardInterrupt as e:
                        msg = f"Sending SIGINT to {args}"
                        Logger.info(msg)

                        # wait until args to end
                        _, stderr = proc.communicate()

                        msg = f"KeyboardInterrupt while running {args}"
                        Logger.warning(msg)
                        raise KeyboardInterrupt(msg) from e

                if proc.returncode != 0:
                    msg = (
                        f"Failed deleting {config}'s {snapshot['number']}: "
                        f"{stderr.strip()}"
                    )
                    Logger.warning(msg)

    @classmethod
    def capture(cls: type["Snapper"]) -> None:
        """Capture new snapshots."""

        msg = "Capturing new snapshot"
        Logger.info(msg)

        proc: "Popen"
        stderr: str
        args: tuple[str, ...]
        for config in cls.get_configs():
            msg = f"Creating new {config}'s snapshot"
            Logger.debug(msg)

            args = (
                Executables.get("snapper"),
                "-c",
                config,
                "create",
                "--description",
                SNAPPER_DESCRIPTION,
                "--type",
                "single",
                "--userdata",
                f"{SNAPPER_USERDATA_KEY_ID}={cls.sync_uuid}",
            )

            with Popen(
                args,
                stdout=DEVNULL,
                stderr=PIPE,
                text=True,
            ) as proc:
                try:
                    _, stderr = proc.communicate()
                except KeyboardInterrupt as e:
                    msg = f"Sending SIGINT to: {args}"
                    Logger.info(msg)

                    # wait until args to end
                    _, stderr = proc.communicate()

                    msg = f"KeyboardInterrupt while running {args}"
                    Logger.warning(msg)
                    raise KeyboardInterrupt(msg) from e

            if proc.returncode != 0:
                msg = f"Failed creating {config}'s snapshot: " f"{stderr.strip()}"
                Logger.error(msg)
                raise Exception(msg)


class SnapRAID:
    """SnapRAID-related functions."""

    _conf: Path
    _vols: set[str]
    _unmanaged_vols: set[str]

    @classmethod
    def is_mount(cls: type["SnapRAID"]) -> bool:
        """Confirm all SnapRAI data volumes are mounted."""

        ret: bool = True
        for vol in cls.get_data_vols():
            if not Path(vol).is_mount():
                msg = f"{vol} is not a mount point"
                Logger.error(msg)
                ret = False

        msg = "Confirm all SnapRAID data volumes are mounted"
        Logger.info(msg)

        return ret

    @classmethod
    def get_unmanaged_vols(cls: type["SnapRAID"]) -> "set":
        """Get snapraid data volumes that are not managed by snapper."""

        if hasattr(cls, "_unmanaged_vols"):
            return cls._unmanaged_vols

        cls._unmanaged_vols = {
            vol
            for vol in SnapRAID.get_data_vols()
            if vol not in {dict_["subvolume"] for dict_ in Snapper.get_configs_raw()}
        }

        return cls._unmanaged_vols

    @classmethod
    def add_config_file(cls: type["SnapRAID"], conf: "Path") -> None:
        """Feed configuration file to class."""
        cls._conf = conf

    @classmethod
    def get_config(cls: type["SnapRAID"]) -> "Path":
        """Get path of configuration file."""

        if not hasattr(cls, "_conf"):
            msg = "feed configuration file to class."
            Logger.error(msg)
            raise Exception(msg)

        return cls._conf

    @classmethod
    def get_data_vols(cls: type["SnapRAID"]) -> set[str]:
        """Get data volumes of snapraid."""

        if hasattr(cls, "_vols"):
            return cls._vols

        with cls.get_config().open(mode="r") as fp:
            cls._vols = {
                line.split()[2] for line in fp.readlines() if line.startswith("data")
            }

        return cls._vols

    @classmethod
    def sync(
        cls: type["SnapRAID"],
        *,
        timeout: int | None = None,
        quite: bool = False,
    ) -> int:
        """
        Run snapraid sync. Return returncode.
        Retrun returncode. Or return sys.maxsize if Timeout/KeyboardInterrupt
        """
        is_paused: bool = False

        if timeout is not None and timeout <= 0:
            msg = f"Invalid timeout value: {timeout}"
            Logger.error(msg)
            raise Exception(msg)

        if timeout:
            msg = f"Starting SnapRAID sync for {timeout/60:.0f}m"
        else:
            msg = "Starting SnapRAID sync"
        Logger.info(msg)

        args: list[str] = [
            Executables.get("ionice"),
            "-c",
            "3",
            Executables.get("snapraid"),
            "sync",
            "--conf",
            str(cls.get_config()),
        ]
        if quite:
            args.append("-q")

        msg = f"New command: {args}"
        Logger.debug(msg)

        with Popen(
            args,
            stdout=sys.stderr,
        ) as proc:
            try:
                proc.wait(timeout=timeout)
            except KeyboardInterrupt as e:
                # NOTE: snapraid-sync returns retruncode 0, after receiving SIGINT <2023-08-13>
                print("", file=sys.stderr)  # noqa: T201
                msg = "Sending SIGINT to SnapRAID sync"
                Logger.info(msg)
                is_paused = True

                # wait until end
                proc.wait()
                msg = f"KeyboardInterrupt while running {args}"
                Logger.warning(msg)

                # raise KeyboardInterrupt(msg) from e
            except TimeoutExpired:
                print("", file=sys.stderr)  # noqa: T201
                msg = "Timeout expired while running SnapRAID sync"
                Logger.info(msg)
                is_paused = True

                proc.send_signal(signal.SIGINT)
                # wait until it ends
                proc.wait()

        if proc.returncode != 0:
            msg = (
                "There is an issue running SnapRAID sync. "
                f"Returncode: {proc.returncode}"
            )
            Logger.warning(msg)

        if is_paused:
            return sys.maxsize

        return proc.returncode

    @classmethod
    def scrub(
        cls: type["SnapRAID"],
        *,
        plan: str,
        older_than: int,
        timeout: int | None = None,
        quite: bool = False,
    ) -> int:
        """Run snapraid scrub."""

        if timeout is not None and timeout <= 0:
            msg = f"Invalid timeout value: {timeout}"
            Logger.error(msg)
            raise Exception(msg)

        if timeout:
            msg = f"Starting SnapRAID scrub for {timeout/60:.0f}m"
        else:
            msg = "Starting SnapRAID scrub"
        Logger.info(msg)

        args: list[str] = [
            Executables.get("ionice"),
            "-c",
            "3",
            Executables.get("snapraid"),
            "--conf",
            str(cls.get_config()),
            "scrub",
            "-p",
            plan,
            "-o",
            str(older_than),
        ]
        if quite:
            args.append("-q")

        msg = f"new command: {args}"
        Logger.debug(msg)

        proc: "Popen"
        with Popen(
            args,
            stdout=sys.stderr,
        ) as proc:
            try:
                proc.wait(timeout=timeout)
            except KeyboardInterrupt:
                # NOTE: snapraid-scrub returns retruncode 0, after receiving SIGINT <2023-08-13>
                print("", file=sys.stderr)  # noqa: T201
                msg = "Sending SIGINT to SnapRAID scrub"
                Logger.info(msg)

                # wait until end
                proc.wait()

                msg = "KeyboardInterrupt while running SnapRAID scrub"
                Logger.warning(msg)

            except TimeoutExpired:
                print("", file=sys.stderr)  # noqa: T201
                msg = "Timeout expired while running SnapRAID scrub"
                Logger.info(msg)
                proc.send_signal(signal.SIGINT)

                # wait until it ends
                proc.wait()

        if proc.returncode != 0:
            msg = (
                "There is an issue running SnapRAID scrub."
                f"Returncode: {proc.returncode}"
            )
            Logger.error(msg)

        return proc.returncode

    @classmethod
    def touch(cls: type["SnapRAID"], *, quite: bool = False) -> int:
        """Run snapraid touch. Return returncode."""

        msg = "Starting SnapRAID touch"
        Logger.info(msg)

        args: list[str] = [
            Executables.get("ionice"),
            "-c",
            "3",
            Executables.get("snapraid"),
            "--conf",
            str(cls.get_config()),
            "touch",
        ]
        if quite:
            args.append("-q")

        msg = f"new command: {args}"
        Logger.debug(msg)

        with Popen(
            args,
            stdout=sys.stderr,
        ) as proc:
            try:
                proc.wait()
            except KeyboardInterrupt as e:
                print("", file=sys.stderr)  # noqa: T201
                msg = "Sending SIGINT to SnapRAID touch"
                Logger.info(msg)

                # wait until end
                proc.wait()

                msg = f"KeyboardInterrupt while running {args}"
                Logger.warning(msg)
                raise KeyboardInterrupt(msg) from e

        if proc.returncode != 0:
            msg = (
                "There is an error running SnapRAID touch. "
                f"Returncode: {proc.returncode}"
            )
            Logger.error(msg)

        return proc.returncode

    @classmethod
    def status(cls: type["SnapRAID"]) -> None:
        """Run snapraid status."""
        msg = "SnapRAID status"
        Logger.info(msg)

        subprocess.run(
            (
                Executables.get("snapraid"),
                "--conf",
                str(cls.get_config()),
                "status",
            ),
            check=True,
            stdout=sys.stderr,
        )


def have_filesystems_changed() -> bool:
    """Findout whether anything has changed since the last sync."""

    if SnapRAID.get_unmanaged_vols():
        msg = "Will not use subvolume comparison using Snapper"
        Logger.info(msg)
        return True

    key: str | None = None
    snapshots: list
    config_snapshot: "dict[str, SnapperSnapshotType]" = {}
    for config in Snapper.get_configs():
        snapshots = Snapper.get_snapshots(config)

        # If snapshot does not exists.
        if len(snapshots) == 0:
            msg = f"A snapshot of {config} does not exists"
            Logger.info(msg)
            return True

        # If multiple snapshots exists
        if len(snapshots) > 1:
            msg = (
                "The last sync was not clean: " f"Multiple snapshots of {config} exists"
            )
            Logger.info(msg)
            return True

        # If key info of snapshots do not match
        if key is None:
            key = snapshots[0][SNAPPER_USERDATA_KEY_ID]
        elif key != snapshots[0][SNAPPER_USERDATA_KEY_ID]:
            msg = (
                "The last sync was not clean: " "The key info of snapshots do not match"
            )
            Logger.info(msg)
            return True

        config_snapshot[config] = snapshots[0]

    ret: bool = True
    with ThreadPoolExecutor() as executor:
        futures: "dict[Future, str]" = {
            executor.submit(Snapper.status, config, snapshot): config
            for config, snapshot in config_snapshot.items()
        }

        for future in as_completed(futures.keys()):
            if not future.result():
                msg = f"{futures[future]} has NOT changed since the last sync"
                Logger.info(msg)
            else:
                msg = f"{futures[future]} has CHANGED since the last sync"
                Logger.info(msg)
                # executor.shutdown(cancel_futures=True)
                return ret

    return False


def check_cond() -> bool:
    """Check if a script can be executed."""
    # check uid
    if os.getuid() == 0:
        msg = "Running as root is not allowed"
        Logger.error(msg)
        return False

    # check os
    if os.name != "posix":
        msg = "OS other than posix ar not supported"
        Logger.error(msg)
        return False

    # check binary
    Executables.check()

    # check volume
    if not SnapRAID.is_mount():
        return False

    # check running process
    for procname in PROCS_TO_CHECK:
        process: "CompletedProcess" = subprocess.run(
            (Executables.get("pgrep"), "-x", procname),
            capture_output=True,
        )

        if process.returncode == 0:
            msg = f"{procname} is running"
            Logger.error(msg)
            return False

    return True


def get_args() -> "Namespace":
    """Return args."""

    parser = ArgumentParser(allow_abbrev=True)
    parser.add_argument(
        "command",
        type=str,
        choices=("sync", "scrub", "all"),
        default="all",
        help="Command to run. Defaults to all",
    )

    parser.add_argument(
        "--conf",
        "-c",
        metavar="FILE",
        type=Path,
        default=Path("/etc/snapraid.conf"),
        nargs="?",
        help="SnapRAID configuration file. Defaults to /etc/snapraid.conf",
    )

    parser.add_argument(
        "--timeout",
        "-t",
        metavar="DURATION",
        help="timout duration for SnapRAID sync in minutes",
        type=int,
    )

    parser.add_argument(
        "--plan",
        "-p",
        metavar="PERCENT|bad|new|full",
        default="10",
        help="SnapRAID scrub plan. Defaults to 10",
        type=str,
    )

    parser.add_argument(
        "--older-than",
        "-o",
        metavar="DAYS",
        default=0,
        help="SnapRAID scrub threshold. Defaults to 0",
        type=int,
    )

    parser.add_argument(
        "--quite",
        "-q",
        action="store_true",
        help="Pass -q to SnapRAID",
    )

    parser.add_argument(
        "--run-touch-before-sync",
        action="store_true",
        help="Run SnapRAID touch before sync",
    )

    parser.add_argument(
        "--force-run-sync",
        action="store_true",
        help=(
            "Always run SnapRAID sync without "
            "checking whether filesystem have changed from last snapshots"
        ),
    )

    parser.add_argument(
        "--ignore-timeout-for-sync",
        action="store_true",
        help=("Always finish SnapRAID sync" "even if a timeout expired"),
    )

    return parser.parse_args()


def check_args(args: "Namespace") -> bool:
    """args의 정합성 체크."""

    ret = True

    if not args.conf.is_file():
        msg = f"{args.conf} does not exists."
        Logger.error(msg)
        ret = False

    if args.timeout is not None and args.timeout <= 0:
        msg = f"Invalid timeout value: {args.timeout}"
        Logger.error(msg)
        ret = False

    if args.older_than is not None and args.older_than < 0:
        msg = f"Invalid older-than value: {args.older_than}"
        Logger.error(msg)
        ret = False

    if not (
        args.plan in {"bad", "new", "full"}
        or (args.plan.isdecimal() and (0 <= int(args.plan) <= 100))  # noqa: PLR2004
    ):
        msg = f"Invalid plan value: {args.plan}"
        Logger.error(msg)
        ret = False

    return ret


def main() -> int:
    """Run scripts."""

    starttime: float = time.time()

    args = get_args()

    SnapRAID.add_config_file(args.conf)

    if not check_args(args):
        return 1

    if not check_cond():
        return 1

    if SnapRAID.get_unmanaged_vols():
        msg = " ".join(
            [
                "Following volumes are not being managed by snapper: ",
                ", ".join(SnapRAID.get_unmanaged_vols()),
            ],
        )
        Logger.warning(msg)

    # Sync SnapRAID
    sync_result = 0
    if args.command in {"sync", "all"} and (
        args.force_run_sync or have_filesystems_changed()
    ):
        if args.run_touch_before_sync:
            SnapRAID.touch(quite=args.quite)

        if isinstance(args.timeout, int) and not args.ignore_timeout_for_sync:
            timeout = args.timeout * 60 - int(time.time() - starttime)
        else:
            timeout = None

        if isinstance(timeout, int) and timeout <= MIN_SNAPRAID_TIMEOUT_SEC:
            msg = "No time left to run sync"
            Logger.info(msg)
        else:
            sync_result = SnapRAID.sync(timeout=timeout, quite=args.quite)
            Snapper.capture()

            if sync_result == 0:
                Snapper.cleanup()

    # Scrub SnapRAID
    if args.command in {"scrub", "all"} and sync_result == 0:
        if isinstance(args.timeout, int):
            timeout = args.timeout * 60 - int(time.time() - starttime)
        else:
            timeout = None

        if isinstance(timeout, int) and timeout <= MIN_SNAPRAID_TIMEOUT_SEC:
            msg = "No time left to run scrub"
            Logger.info(msg)
        else:
            SnapRAID.scrub(
                plan=args.plan,
                older_than=args.older_than,
                timeout=timeout,
                quite=args.quite,
            )
    return 0


if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        msg = "KeyboardInterrupt"
        Logger.info(msg)
        sys.exit(130)
