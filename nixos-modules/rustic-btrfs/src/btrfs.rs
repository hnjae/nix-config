/// FFI bindings for libbtrfsutil generated by bindgen
#[allow(
    non_upper_case_globals,
    non_camel_case_types,
    non_snake_case,
    dead_code,
    clippy::all
)]
mod ffi {
    include!(concat!(env!("OUT_DIR"), "/btrfs_bindings.rs"));
}

use crate::traits::{BtrfsOps, Error};
use std::path::Path;

/// Production implementation of BtrfsOps using libbtrfsutil.
pub struct LibBtrfs;

impl LibBtrfs {
    /// Create a new LibBtrfs instance.
    #[must_use]
    pub const fn new() -> Self {
        Self
    }
}

impl Default for LibBtrfs {
    fn default() -> Self {
        Self::new()
    }
}

impl BtrfsOps for LibBtrfs {
    fn get_subvolume_uuid(&self, _path: &Path) -> Result<String, Error> {
        // TODO: Implement using btrfs_util_subvolume_info()
        // Extract UUID and format as RFC 4122 (lowercase, hyphenated)
        Err(Error::Other("Not implemented yet".to_string()))
    }

    fn is_subvolume(&self, _path: &Path) -> Result<bool, Error> {
        // TODO: Implement using btrfs_util_is_subvolume()
        Err(Error::Other("Not implemented yet".to_string()))
    }

    fn create_snapshot(&self, _source: &Path, _dest: &Path, _readonly: bool) -> Result<(), Error> {
        // TODO: Implement using btrfs_util_create_snapshot()
        Err(Error::Other("Not implemented yet".to_string()))
    }

    fn delete_subvolume(&self, _path: &Path) -> Result<(), Error> {
        // TODO: Implement using btrfs_util_delete_subvolume()
        Err(Error::Other("Not implemented yet".to_string()))
    }
}

/// Format a raw UUID byte array to RFC 4122 format (lowercase, hyphenated).
///
/// # Arguments
///
/// * `uuid` - 16-byte UUID array
///
/// # Returns
///
/// Formatted UUID string: `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`
///
/// # Example
///
/// ```ignore
/// let uuid = [0x5e, 0xa0, 0x18, 0x52, 0xb4, 0xf9, 0x4e, 0x4a,
///             0x9c, 0x9d, 0xf9, 0xc8, 0xb7, 0xa6, 0xe5, 0xd4];
/// let formatted = format_uuid(&uuid);
/// assert_eq!(formatted, "5ea01852-b4f9-4e4a-9c9d-f9c8b7a6e5d4");
/// ```
#[must_use]
pub fn format_uuid(uuid: &[u8; 16]) -> String {
    format!(
        "{:02x}{:02x}{:02x}{:02x}-{:02x}{:02x}-{:02x}{:02x}-{:02x}{:02x}-{:02x}{:02x}{:02x}{:02x}{:02x}{:02x}",
        uuid[0],
        uuid[1],
        uuid[2],
        uuid[3],
        uuid[4],
        uuid[5],
        uuid[6],
        uuid[7],
        uuid[8],
        uuid[9],
        uuid[10],
        uuid[11],
        uuid[12],
        uuid[13],
        uuid[14],
        uuid[15]
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_format_uuid() {
        let uuid = [
            0x5e, 0xa0, 0x18, 0x52, 0xb4, 0xf9, 0x4e, 0x4a, 0x9c, 0x9d, 0xf9, 0xc8, 0xb7, 0xa6,
            0xe5, 0xd4,
        ];
        assert_eq!(format_uuid(&uuid), "5ea01852-b4f9-4e4a-9c9d-f9c8b7a6e5d4");
    }
}
