/// FFI bindings for libbtrfsutil generated by bindgen
#[allow(
    non_upper_case_globals,
    non_camel_case_types,
    non_snake_case,
    dead_code,
    clippy::all
)]
mod ffi {
    include!(concat!(env!("OUT_DIR"), "/btrfs_bindings.rs"));
}

use crate::traits::{BtrfsOps, Error};
use std::ffi::CString;
use std::path::Path;

/// Production implementation of BtrfsOps using libbtrfsutil.
pub struct LibBtrfs;

impl LibBtrfs {
    /// Create a new LibBtrfs instance.
    #[must_use]
    pub const fn new() -> Self {
        Self
    }
}

impl Default for LibBtrfs {
    fn default() -> Self {
        Self::new()
    }
}

impl BtrfsOps for LibBtrfs {
    fn get_subvolume_uuid(&self, path: &Path) -> Result<String, Error> {
        log::debug!("Getting UUID for subvolume: {}", path.display());

        let path_str = path
            .to_str()
            .ok_or_else(|| Error::Other("Invalid UTF-8 in path".to_string()))?;
        let c_path = CString::new(path_str)
            .map_err(|e| Error::Other(format!("Invalid path (contains null byte): {e}")))?;

        unsafe {
            let mut info: ffi::btrfs_util_subvolume_info = std::mem::zeroed();
            let err = ffi::btrfs_util_subvolume_info(c_path.as_ptr(), 0, &mut info);

            if err != ffi::btrfs_util_error::BTRFS_UTIL_OK {
                return Err(Error::BtrfsError(format!(
                    "Failed to get subvolume info: error code {err:?}"
                )));
            }

            // Extract UUID from info.uuid (16 bytes)
            let uuid: [u8; 16] = info.uuid;
            let uuid_str = format_uuid(&uuid);
            log::debug!("Subvolume UUID: {uuid_str}");
            Ok(uuid_str)
        }
    }

    fn is_subvolume(&self, path: &Path) -> Result<bool, Error> {
        let path_str = path
            .to_str()
            .ok_or_else(|| Error::Other("Invalid UTF-8 in path".to_string()))?;
        let c_path = CString::new(path_str)
            .map_err(|e| Error::Other(format!("Invalid path (contains null byte): {e}")))?;

        unsafe {
            let err = ffi::btrfs_util_is_subvolume(c_path.as_ptr());

            match err {
                ffi::btrfs_util_error::BTRFS_UTIL_OK => Ok(true),
                ffi::btrfs_util_error::BTRFS_UTIL_ERROR_NOT_BTRFS
                | ffi::btrfs_util_error::BTRFS_UTIL_ERROR_NOT_SUBVOLUME => Ok(false),
                _ => Err(Error::BtrfsError(format!(
                    "Failed to check if path is subvolume: error code {err:?}"
                ))),
            }
        }
    }

    fn create_snapshot(&self, source: &Path, dest: &Path, readonly: bool) -> Result<(), Error> {
        log::info!(
            "Creating {} snapshot: {} -> {}",
            if readonly { "read-only" } else { "writable" },
            source.display(),
            dest.display()
        );

        let source_str = source
            .to_str()
            .ok_or_else(|| Error::Other("Invalid UTF-8 in source path".to_string()))?;
        let dest_str = dest
            .to_str()
            .ok_or_else(|| Error::Other("Invalid UTF-8 in dest path".to_string()))?;

        let c_source = CString::new(source_str)
            .map_err(|e| Error::Other(format!("Invalid source path (contains null byte): {e}")))?;
        let c_dest = CString::new(dest_str)
            .map_err(|e| Error::Other(format!("Invalid dest path (contains null byte): {e}")))?;

        unsafe {
            let flags = if readonly {
                ffi::BTRFS_UTIL_CREATE_SNAPSHOT_READ_ONLY
            } else {
                0
            };

            #[allow(clippy::as_conversions)]
            let err = ffi::btrfs_util_create_snapshot(
                c_source.as_ptr(),
                c_dest.as_ptr(),
                flags as i32,
                std::ptr::null_mut(),
                std::ptr::null_mut(),
            );

            if err != ffi::btrfs_util_error::BTRFS_UTIL_OK {
                log::error!("Failed to create snapshot: error code {err:?}");
                return Err(Error::SnapshotCreation(format!(
                    "Failed to create snapshot: error code {err:?}"
                )));
            }

            log::info!("Snapshot created successfully");
            Ok(())
        }
    }

    fn delete_subvolume(&self, path: &Path) -> Result<(), Error> {
        log::info!("Deleting subvolume: {}", path.display());

        let path_str = path
            .to_str()
            .ok_or_else(|| Error::Other("Invalid UTF-8 in path".to_string()))?;
        let c_path = CString::new(path_str)
            .map_err(|e| Error::Other(format!("Invalid path (contains null byte): {e}")))?;

        unsafe {
            let err = ffi::btrfs_util_delete_subvolume(c_path.as_ptr(), 0);

            if err != ffi::btrfs_util_error::BTRFS_UTIL_OK {
                log::warn!("Failed to delete subvolume: error code {err:?}");
                return Err(Error::SnapshotDeletion(format!(
                    "Failed to delete subvolume: error code {err:?}"
                )));
            }

            log::info!("Subvolume deleted successfully");
            Ok(())
        }
    }
}

/// Format a raw UUID byte array to RFC 4122 format (lowercase, hyphenated).
///
/// # Arguments
///
/// * `uuid` - 16-byte UUID array
///
/// # Returns
///
/// Formatted UUID string: `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`
///
/// # Example
///
/// ```ignore
/// let uuid = [0x5e, 0xa0, 0x18, 0x52, 0xb4, 0xf9, 0x4e, 0x4a,
///             0x9c, 0x9d, 0xf9, 0xc8, 0xb7, 0xa6, 0xe5, 0xd4];
/// let formatted = format_uuid(&uuid);
/// assert_eq!(formatted, "5ea01852-b4f9-4e4a-9c9d-f9c8b7a6e5d4");
/// ```
#[must_use]
pub fn format_uuid(uuid: &[u8; 16]) -> String {
    format!(
        "{:02x}{:02x}{:02x}{:02x}-{:02x}{:02x}-{:02x}{:02x}-{:02x}{:02x}-{:02x}{:02x}{:02x}{:02x}{:02x}{:02x}",
        uuid[0],
        uuid[1],
        uuid[2],
        uuid[3],
        uuid[4],
        uuid[5],
        uuid[6],
        uuid[7],
        uuid[8],
        uuid[9],
        uuid[10],
        uuid[11],
        uuid[12],
        uuid[13],
        uuid[14],
        uuid[15]
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_format_uuid() {
        let uuid = [
            0x5e, 0xa0, 0x18, 0x52, 0xb4, 0xf9, 0x4e, 0x4a, 0x9c, 0x9d, 0xf9, 0xc8, 0xb7, 0xa6,
            0xe5, 0xd4,
        ];
        assert_eq!(format_uuid(&uuid), "5ea01852-b4f9-4e4a-9c9d-f9c8b7a6e5d4");
    }
}
